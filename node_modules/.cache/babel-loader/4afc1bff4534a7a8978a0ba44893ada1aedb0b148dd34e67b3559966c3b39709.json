{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out (default: `true`).\n */\n\nimport { convert } from 'unist-util-is';\nconst own = {}.hasOwnProperty;\n\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @template {Node} Tree\n * @template {Test} Check\n *\n * @overload\n * @param {Tree} tree\n * @param {Options | null | undefined} options\n * @param {Check} test\n * @returns {import('./complex-types.js').Matches<Tree, Check>}\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} test\n * @returns {import('./complex-types.js').Matches<Tree, Check>}\n *\n * @overload\n * @param {Tree} tree\n * @param {null | undefined} [options]\n * @returns {Tree}\n *\n * @param {Node} tree\n *   Tree to filter.\n * @param {Options | Test} [options]\n *   Configuration (optional).\n * @param {Test} [test]\n *   `unist-util-is` compatible test.\n * @returns {Node | undefined}\n *   New filtered tree.\n *\n *   `undefined` is returned if `tree` itself didn’t pass the test, or is\n *   cascaded away.\n */\nexport function filter(tree, options, test) {\n  const is = convert(test || options);\n  const cascadeRaw = options && typeof options === 'object' && 'cascade' in options ? (/** @type {boolean | null | undefined} */options.cascade) : undefined;\n  const cascade = cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw;\n  return preorder(tree);\n\n  /**\n   * @param {Node} node\n   *   Current node.\n   * @param {number | undefined} [index]\n   *   Index of `node` in `parent`.\n   * @param {Parent | undefined} [parentNode]\n   *   Parent node.\n   * @returns {Node | undefined}\n   *   Shallow copy of `node`.\n   */\n  function preorder(node, index, parentNode) {\n    /** @type {Array<Node>} */\n    const children = [];\n    if (!is(node, index, parentNode)) return undefined;\n    if (parent(node)) {\n      let childIndex = -1;\n      while (++childIndex < node.children.length) {\n        const result = preorder(node.children[childIndex], childIndex, node);\n        if (result) {\n          children.push(result);\n        }\n      }\n      if (cascade && node.children.length > 0 && children.length === 0) {\n        return undefined;\n      }\n    }\n\n    // Create a shallow clone, using the new children.\n    /** @type {typeof node} */\n    // @ts-expect-error all the fields will be copied over.\n    const next = {};\n    /** @type {string} */\n    let key;\n    for (key in node) {\n      if (own.call(node, key)) {\n        // @ts-expect-error: Looks like a record.\n        next[key] = key === 'children' ? children : node[key];\n      }\n    }\n    return next;\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {node is Parent}\n */\nfunction parent(node) {\n  return 'children' in node && node.children !== undefined;\n}","map":{"version":3,"names":["convert","own","hasOwnProperty","filter","tree","options","test","is","cascadeRaw","cascade","undefined","preorder","node","index","parentNode","children","parent","childIndex","length","result","push","next","key","call"],"sources":["C:/Users/mytao/OneDrive/Desktop/practice/Practice/StudyTool/react-learning-platform/node_modules/unist-util-filter/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [cascade=true]\n *   Whether to drop parent nodes if they had children, but all their children\n *   were filtered out (default: `true`).\n */\n\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a new `tree` of copies of all nodes that pass `test`.\n *\n * The tree is walked in *preorder* (NLR), visiting the node itself, then its\n * head, etc.\n *\n * @template {Node} Tree\n * @template {Test} Check\n *\n * @overload\n * @param {Tree} tree\n * @param {Options | null | undefined} options\n * @param {Check} test\n * @returns {import('./complex-types.js').Matches<Tree, Check>}\n *\n * @overload\n * @param {Tree} tree\n * @param {Check} test\n * @returns {import('./complex-types.js').Matches<Tree, Check>}\n *\n * @overload\n * @param {Tree} tree\n * @param {null | undefined} [options]\n * @returns {Tree}\n *\n * @param {Node} tree\n *   Tree to filter.\n * @param {Options | Test} [options]\n *   Configuration (optional).\n * @param {Test} [test]\n *   `unist-util-is` compatible test.\n * @returns {Node | undefined}\n *   New filtered tree.\n *\n *   `undefined` is returned if `tree` itself didn’t pass the test, or is\n *   cascaded away.\n */\nexport function filter(tree, options, test) {\n  const is = convert(test || options)\n  const cascadeRaw =\n    options && typeof options === 'object' && 'cascade' in options\n      ? /** @type {boolean | null | undefined} */ (options.cascade)\n      : undefined\n  const cascade =\n    cascadeRaw === undefined || cascadeRaw === null ? true : cascadeRaw\n\n  return preorder(tree)\n\n  /**\n   * @param {Node} node\n   *   Current node.\n   * @param {number | undefined} [index]\n   *   Index of `node` in `parent`.\n   * @param {Parent | undefined} [parentNode]\n   *   Parent node.\n   * @returns {Node | undefined}\n   *   Shallow copy of `node`.\n   */\n  function preorder(node, index, parentNode) {\n    /** @type {Array<Node>} */\n    const children = []\n\n    if (!is(node, index, parentNode)) return undefined\n\n    if (parent(node)) {\n      let childIndex = -1\n\n      while (++childIndex < node.children.length) {\n        const result = preorder(node.children[childIndex], childIndex, node)\n\n        if (result) {\n          children.push(result)\n        }\n      }\n\n      if (cascade && node.children.length > 0 && children.length === 0) {\n        return undefined\n      }\n    }\n\n    // Create a shallow clone, using the new children.\n    /** @type {typeof node} */\n    // @ts-expect-error all the fields will be copied over.\n    const next = {}\n    /** @type {string} */\n    let key\n\n    for (key in node) {\n      if (own.call(node, key)) {\n        // @ts-expect-error: Looks like a record.\n        next[key] = key === 'children' ? children : node[key]\n      }\n    }\n\n    return next\n  }\n}\n\n/**\n * @param {Node} node\n * @returns {node is Parent}\n */\nfunction parent(node) {\n  return 'children' in node && node.children !== undefined\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,OAAO,QAAO,eAAe;AAErC,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACC,IAAI,EAAEC,OAAO,EAAEC,IAAI,EAAE;EAC1C,MAAMC,EAAE,GAAGP,OAAO,CAACM,IAAI,IAAID,OAAO,CAAC;EACnC,MAAMG,UAAU,GACdH,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAI,SAAS,IAAIA,OAAO,IAC1D,yCAA2CA,OAAO,CAACI,OAAO,IAC1DC,SAAS;EACf,MAAMD,OAAO,GACXD,UAAU,KAAKE,SAAS,IAAIF,UAAU,KAAK,IAAI,GAAG,IAAI,GAAGA,UAAU;EAErE,OAAOG,QAAQ,CAACP,IAAI,CAAC;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASO,QAAQA,CAACC,IAAI,EAAEC,KAAK,EAAEC,UAAU,EAAE;IACzC;IACA,MAAMC,QAAQ,GAAG,EAAE;IAEnB,IAAI,CAACR,EAAE,CAACK,IAAI,EAAEC,KAAK,EAAEC,UAAU,CAAC,EAAE,OAAOJ,SAAS;IAElD,IAAIM,MAAM,CAACJ,IAAI,CAAC,EAAE;MAChB,IAAIK,UAAU,GAAG,CAAC,CAAC;MAEnB,OAAO,EAAEA,UAAU,GAAGL,IAAI,CAACG,QAAQ,CAACG,MAAM,EAAE;QAC1C,MAAMC,MAAM,GAAGR,QAAQ,CAACC,IAAI,CAACG,QAAQ,CAACE,UAAU,CAAC,EAAEA,UAAU,EAAEL,IAAI,CAAC;QAEpE,IAAIO,MAAM,EAAE;UACVJ,QAAQ,CAACK,IAAI,CAACD,MAAM,CAAC;QACvB;MACF;MAEA,IAAIV,OAAO,IAAIG,IAAI,CAACG,QAAQ,CAACG,MAAM,GAAG,CAAC,IAAIH,QAAQ,CAACG,MAAM,KAAK,CAAC,EAAE;QAChE,OAAOR,SAAS;MAClB;IACF;;IAEA;IACA;IACA;IACA,MAAMW,IAAI,GAAG,CAAC,CAAC;IACf;IACA,IAAIC,GAAG;IAEP,KAAKA,GAAG,IAAIV,IAAI,EAAE;MAChB,IAAIX,GAAG,CAACsB,IAAI,CAACX,IAAI,EAAEU,GAAG,CAAC,EAAE;QACvB;QACAD,IAAI,CAACC,GAAG,CAAC,GAAGA,GAAG,KAAK,UAAU,GAAGP,QAAQ,GAAGH,IAAI,CAACU,GAAG,CAAC;MACvD;IACF;IAEA,OAAOD,IAAI;EACb;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASL,MAAMA,CAACJ,IAAI,EAAE;EACpB,OAAO,UAAU,IAAIA,IAAI,IAAIA,IAAI,CAACG,QAAQ,KAAKL,SAAS;AAC1D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}