{"ast":null,"code":"/**\n * @import {Root} from 'hast'\n * @import {ParserError} from 'parse5'\n * @import {Value} from 'vfile'\n * @import {ErrorCode, Options} from './types.js'\n */\n\nimport { ok as assert } from 'devlop';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { parse, parseFragment } from 'parse5';\nimport { VFile } from 'vfile';\nimport { VFileMessage } from 'vfile-message';\nimport { errors } from './errors.js';\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-';\nconst dashToCamelRe = /-[a-z]/g;\nconst formatCRe = /%c(?:([-+])(\\d+))?/g;\nconst formatXRe = /%x/g;\nconst fatalities = {\n  2: true,\n  1: false,\n  0: null\n};\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {};\n\n/**\n * Turn serialized HTML into a hast tree.\n *\n * @param {VFile | Value} value\n *   Serialized HTML to parse.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Root}\n *   Tree.\n */\nexport function fromHtml(value, options) {\n  const settings = options || emptyOptions;\n  const onerror = settings.onerror;\n  const file = value instanceof VFile ? value : new VFile(value);\n  const parseFunction = settings.fragment ? parseFragment : parse;\n  const document = String(file);\n  const p5Document = parseFunction(document, {\n    sourceCodeLocationInfo: true,\n    // Note `parse5` types currently do not allow `undefined`.\n    onParseError: settings.onerror ? internalOnerror : null,\n    scriptingEnabled: false\n  });\n\n  // `parse5` returns document which are always mapped to roots.\n  return /** @type {Root} */fromParse5(p5Document, {\n    file,\n    space: settings.space,\n    verbose: settings.verbose\n  });\n\n  /**\n   * Handle a parse error.\n   *\n   * @param {ParserError} error\n   *   Parse5 error.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function internalOnerror(error) {\n    const code = error.code;\n    const name = camelcase(code);\n    const setting = settings[name];\n    const config = setting === null || setting === undefined ? true : setting;\n    const level = typeof config === 'number' ? config : config ? 1 : 0;\n    if (level) {\n      const info = errors[name];\n      assert(info, 'expected known error from `parse5`');\n      const message = new VFileMessage(format(info.reason), {\n        place: {\n          start: {\n            line: error.startLine,\n            column: error.startCol,\n            offset: error.startOffset\n          },\n          end: {\n            line: error.endLine,\n            column: error.endCol,\n            offset: error.endOffset\n          }\n        },\n        ruleId: code,\n        source: 'hast-util-from-html'\n      });\n      if (file.path) {\n        message.file = file.path;\n        message.name = file.path + ':' + message.name;\n      }\n      message.fatal = fatalities[level];\n      message.note = format(info.description);\n      message.url = info.url === false ? undefined : base + code;\n      assert(onerror, '`internalOnerror` is not passed if `onerror` is not set');\n      onerror(message);\n    }\n\n    /**\n     * Format a human readable string about an error.\n     *\n     * @param {string} value\n     *   Value to format.\n     * @returns {string}\n     *   Formatted.\n     */\n    function format(value) {\n      return value.replace(formatCRe, formatC).replace(formatXRe, formatX);\n\n      /**\n       * Format the character.\n       *\n       * @param {string} _\n       *   Match.\n       * @param {string} $1\n       *   Sign (`-` or `+`, optional).\n       * @param {string} $2\n       *   Offset.\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatC(_, $1, $2) {\n        const offset = ($2 ? Number.parseInt($2, 10) : 0) * ($1 === '-' ? -1 : 1);\n        const char = document.charAt(error.startOffset + offset);\n        return visualizeCharacter(char);\n      }\n\n      /**\n       * Format the character code.\n       *\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatX() {\n        return visualizeCharacterCode(document.charCodeAt(error.startOffset));\n      }\n    }\n  }\n}\n\n/**\n * @param {string} value\n *   Error code in dash case.\n * @returns {ErrorCode}\n *   Error code in camelcase.\n */\nfunction camelcase(value) {\n  // This should match an error code.\n  return /** @type {ErrorCode} */value.replace(dashToCamelRe, dashToCamel);\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @returns {string}\n *   Camelcased.\n */\nfunction dashToCamel($0) {\n  return $0.charAt(1).toUpperCase();\n}\n\n/**\n * @param {string} char\n *   Character.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacter(char) {\n  return char === '`' ? '` ` `' : char;\n}\n\n/**\n * @param {number} charCode\n *   Character code.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacterCode(charCode) {\n  return '0x' + charCode.toString(16).toUpperCase();\n}","map":{"version":3,"names":["ok","assert","fromParse5","parse","parseFragment","VFile","VFileMessage","errors","base","dashToCamelRe","formatCRe","formatXRe","fatalities","emptyOptions","fromHtml","value","options","settings","onerror","file","parseFunction","fragment","document","String","p5Document","sourceCodeLocationInfo","onParseError","internalOnerror","scriptingEnabled","space","verbose","error","code","name","camelcase","setting","config","undefined","level","info","message","format","reason","place","start","line","startLine","column","startCol","offset","startOffset","end","endLine","endCol","endOffset","ruleId","source","path","fatal","note","description","url","replace","formatC","formatX","_","$1","$2","Number","parseInt","char","charAt","visualizeCharacter","visualizeCharacterCode","charCodeAt","dashToCamel","$0","toUpperCase","charCode","toString"],"sources":["C:/Users/mytao/OneDrive/Desktop/practice/Practice/StudyTool/react-learning-platform/node_modules/hast-util-from-html/lib/index.js"],"sourcesContent":["/**\n * @import {Root} from 'hast'\n * @import {ParserError} from 'parse5'\n * @import {Value} from 'vfile'\n * @import {ErrorCode, Options} from './types.js'\n */\n\nimport {ok as assert} from 'devlop'\nimport {fromParse5} from 'hast-util-from-parse5'\nimport {parse, parseFragment} from 'parse5'\nimport {VFile} from 'vfile'\nimport {VFileMessage} from 'vfile-message'\nimport {errors} from './errors.js'\n\nconst base = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-'\n\nconst dashToCamelRe = /-[a-z]/g\nconst formatCRe = /%c(?:([-+])(\\d+))?/g\nconst formatXRe = /%x/g\n\nconst fatalities = {2: true, 1: false, 0: null}\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Turn serialized HTML into a hast tree.\n *\n * @param {VFile | Value} value\n *   Serialized HTML to parse.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Root}\n *   Tree.\n */\nexport function fromHtml(value, options) {\n  const settings = options || emptyOptions\n  const onerror = settings.onerror\n  const file = value instanceof VFile ? value : new VFile(value)\n  const parseFunction = settings.fragment ? parseFragment : parse\n  const document = String(file)\n  const p5Document = parseFunction(document, {\n    sourceCodeLocationInfo: true,\n    // Note `parse5` types currently do not allow `undefined`.\n    onParseError: settings.onerror ? internalOnerror : null,\n    scriptingEnabled: false\n  })\n\n  // `parse5` returns document which are always mapped to roots.\n  return /** @type {Root} */ (\n    fromParse5(p5Document, {\n      file,\n      space: settings.space,\n      verbose: settings.verbose\n    })\n  )\n\n  /**\n   * Handle a parse error.\n   *\n   * @param {ParserError} error\n   *   Parse5 error.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function internalOnerror(error) {\n    const code = error.code\n    const name = camelcase(code)\n    const setting = settings[name]\n    const config = setting === null || setting === undefined ? true : setting\n    const level = typeof config === 'number' ? config : config ? 1 : 0\n\n    if (level) {\n      const info = errors[name]\n      assert(info, 'expected known error from `parse5`')\n\n      const message = new VFileMessage(format(info.reason), {\n        place: {\n          start: {\n            line: error.startLine,\n            column: error.startCol,\n            offset: error.startOffset\n          },\n          end: {\n            line: error.endLine,\n            column: error.endCol,\n            offset: error.endOffset\n          }\n        },\n        ruleId: code,\n        source: 'hast-util-from-html'\n      })\n\n      if (file.path) {\n        message.file = file.path\n        message.name = file.path + ':' + message.name\n      }\n\n      message.fatal = fatalities[level]\n      message.note = format(info.description)\n      message.url = info.url === false ? undefined : base + code\n\n      assert(onerror, '`internalOnerror` is not passed if `onerror` is not set')\n      onerror(message)\n    }\n\n    /**\n     * Format a human readable string about an error.\n     *\n     * @param {string} value\n     *   Value to format.\n     * @returns {string}\n     *   Formatted.\n     */\n    function format(value) {\n      return value.replace(formatCRe, formatC).replace(formatXRe, formatX)\n\n      /**\n       * Format the character.\n       *\n       * @param {string} _\n       *   Match.\n       * @param {string} $1\n       *   Sign (`-` or `+`, optional).\n       * @param {string} $2\n       *   Offset.\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatC(_, $1, $2) {\n        const offset =\n          ($2 ? Number.parseInt($2, 10) : 0) * ($1 === '-' ? -1 : 1)\n        const char = document.charAt(error.startOffset + offset)\n        return visualizeCharacter(char)\n      }\n\n      /**\n       * Format the character code.\n       *\n       * @returns {string}\n       *   Formatted.\n       */\n      function formatX() {\n        return visualizeCharacterCode(document.charCodeAt(error.startOffset))\n      }\n    }\n  }\n}\n\n/**\n * @param {string} value\n *   Error code in dash case.\n * @returns {ErrorCode}\n *   Error code in camelcase.\n */\nfunction camelcase(value) {\n  // This should match an error code.\n  return /** @type {ErrorCode} */ (value.replace(dashToCamelRe, dashToCamel))\n}\n\n/**\n * @param {string} $0\n *   Match.\n * @returns {string}\n *   Camelcased.\n */\nfunction dashToCamel($0) {\n  return $0.charAt(1).toUpperCase()\n}\n\n/**\n * @param {string} char\n *   Character.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacter(char) {\n  return char === '`' ? '` ` `' : char\n}\n\n/**\n * @param {number} charCode\n *   Character code.\n * @returns {string}\n *   Formatted.\n */\nfunction visualizeCharacterCode(charCode) {\n  return '0x' + charCode.toString(16).toUpperCase()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}